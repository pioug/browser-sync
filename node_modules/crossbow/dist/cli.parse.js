"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("../lodash.custom");
var CliFlagTypes;
(function (CliFlagTypes) {
    CliFlagTypes[CliFlagTypes["Array"] = "array"] = "Array";
    CliFlagTypes[CliFlagTypes["String"] = "string"] = "String";
    CliFlagTypes[CliFlagTypes["Boolean"] = "boolean"] = "Boolean";
    CliFlagTypes[CliFlagTypes["Number"] = "number"] = "Number";
    CliFlagTypes[CliFlagTypes["Count"] = "count"] = "Count";
})(CliFlagTypes = exports.CliFlagTypes || (exports.CliFlagTypes = {}));
/**
 * Accept either string or array input
 */
function parse(input, opts) {
    opts = opts || {};
    if (Array.isArray(input)) {
        return parseArray(input, opts);
    }
    // string given
    return parseArray(tokenize(input), opts);
}
exports.default = parse;
function parseArray(incoming, opts) {
    var command = incoming[0];
    var args = (function () {
        var _incoming = incoming.slice(1);
        var _terminator = _incoming.indexOf("--");
        if (_terminator > -1) {
            return {
                args: _incoming.slice(0, _terminator),
                trailing: _incoming.slice(_terminator + 1).join(" ")
            };
        }
        return {
            args: _incoming,
            trailing: ""
        };
    })();
    var split = splitInputFromFlags(args.args);
    var flagValues = resolveValues(split.flags, opts);
    var flattened = flattenValues(flagValues.flags);
    return {
        command: command,
        input: [command].concat(split.input, flagValues.input),
        rawFlags: split.flags,
        flagValues: flagValues.flags,
        flags: flattened,
        trailing: args.trailing
    };
}
function splitInputFromFlags(args) {
    var firstFlag = firstFlagPos(args);
    var trailing = [];
    /**
     * Input is args directly after the command, or at the end
     * eg:
     *     $ crossbow run task1 task2 -p 8000
     * ->
     *      ['task1', 'task2']
     * eg:
     *     $ crossbow run task1 task2 -p 8000 -- task3 task4
     * ->
     *      ['task1', 'task2', 'task3', 'task4']
     */
    var input = (function () {
        // no flags given
        if (firstFlag === -1)
            return args.slice();
        // flag given at first position, so no input
        if (firstFlag === 0)
            return [];
        // flag at later point, so slice items upto it
        return args.slice(0, firstFlag);
    })();
    /**
     * Create the raw flags array
     * @type {any[][]}
     */
    var flags = args
        /**
         * Look at each item, discard none-flags & and trim to the right
         * for every one. This is what will allow the multi options later
         * eg:
         *    'task1 -p --before task2 task3 -pc
         *  ->
         *      [
         *          ['-p', '--before', 'task2', 'task3', '-pc],
         *          ['--before', 'task2', 'task3', '-pc'],
         *          ['-pc']
         *      ]
         */
        .reduce(function groupRight(acc, item, i) {
        if (isFlag(item)) {
            return acc.concat([args.slice(i)]);
        }
        return acc;
    }, [])
        /**
         * Now try to slice out a section that applies to this flag only
         * eg:
         *    ['-p', '--before', 'task2', 'task3', '-pc']
         * -> (slice 0, 1)
         *    ['-p']
         * eg:
         *    ['--before', 'task2', 'task3', '-pc']
         * -> (slice  0, 3)
         *    ['--before', 'task2', 'task3']
         * eg:
         *    ['-pc]
         * -> (slice -1)
         *    ['-pc']
         */
        .map(function getSubSection(flag) {
        /**
         * Get the slice index (if followed by another flag at some point
         */
        var slicePoint = (function () {
            return flag.slice(1)
                .reduce(function (acc, item, i) {
                if (acc === -1) {
                    // not set
                    if (isFlag(item))
                        return i + 1;
                }
                return acc;
            }, -1);
        })();
        /**
         * If no flag followed, check if the first item is itself a flag.
         * Situations that would lead us here include:
         * eg:
         *   [ '-pc' ]
         */
        if (slicePoint === -1) {
            if (isFlag(flag[0])) {
                if (hasSetter(flag[0])) {
                    /**
                     * Slice everything to the end and add to the input array
                     */
                    input = input.concat(flag.slice(1));
                    return flag.slice(0, 1);
                }
            }
            /**
             * At this point, there was NO FLAG FOLLOWING this flag, so any items
             * after it are considered to be belong to this item.
             * eg:
             *
             *      'run -p 8000 -v $(pwd):/var/www --before task1 task2
             *
             * -> task1 & task2 are values of --before & not program inputs
             */
            return flag;
        }
        /**
         * Outgoing array is the sliced subsection,
         * eg:
         *     [ '--before', 'task2', 'task3' ]
         */
        var outgoing = flag.slice(0, slicePoint);
        /**
         * A final check if the first item was a setter (ie, it contained an equals = sign).
         * If so, we only want that item and again shove the other items into the input
         * eg:
         *
         *   [ '--beep=boop', 'task1', 'task2' ]
         *
         * -> task1 & task2 go to the input and --beep=boop used separately
         */
        if (hasSetter(outgoing[0])) {
            input = input.concat(outgoing.slice(1));
            return [outgoing[0]];
        }
        /**
         * Standard use-case when we reach here, like
         * [ '-p' ]
         * [ '--before', 'task2', 'task3' ]
         * [ '-pc', 'another' ]
         * etc
         */
        return flag.slice(0, slicePoint);
    })
        /**
         * If a single item made it through with a setter, split on the equals
         *
         * eg:
         *      ['--boop=boop']
         *
         * ->
         *      ['--boop', 'boop']
         */
        .map(function splitSetters(item) {
        if (item.length === 1) {
            return item[0].split(/=/);
        }
        return item;
    })
        /**
         * If multiple-single-booleans were given, treat at individual
         *
         * eg:
         *      ['-abc']
         * ->
         *      ['-a', '-b', '-c']
         */
        .reduce(function normalizeFormat(acc, item) {
        if (item.length === 1) {
            // Double flag
            if (item[0].slice(0, 2) === "--") {
                return acc.concat([item]);
            }
            // Single flag
            var current = item[0].slice(1);
            return acc.concat(current.split("").map(function (x) { return ["-" + x]; }));
        }
        /**
         * If -- encountered at the end, push items onto input
         */
        if (item[0] === "--") {
            trailing.push.apply(trailing, item.slice(1));
            return acc;
        }
        return acc.concat([item]);
    }, [])
        /**
         * Now simplify into [propname, ..rest]
         */
        .map(function createObject(x) {
        return [propName(x[0])].concat(x.slice(1));
    });
    return { input: input, flags: flags };
}
/**
 * At this stage, every flag has a values collections.
 * Depending on the type (if given) - try to set the value to
 * what the user expects.
 * eg:
 *     -vvv
 *
 * config: {v: {type: count}}
 *
 * ->
 *     {v: 3}
 *
 * @param flagValues
 * @returns {{}}
 */
var negatedBool = /^no-(.*)/;
function flattenValues(flagValues) {
    return Object.keys(flagValues).reduce(function (obj, key) {
        /**
         * Here, current would be the values associated with
         * a flag.
         *  eg: values: [true, true]
         */
        var current = flagValues[key];
        /**
         * The keyToSet may be the same as the current item,
         * or if negated could be minus the no-(.*) section
         *  eg:
         *    no-fail -> fail
         *    suppress -> suppress
         */
        var keyToSet = key;
        /**
         * Now we determine which value should
         * be set on the current item.
         */
        var valueToSet = (function () {
            /**
             * Did the used try to negate a boolean.
             *
             * eg:
             *
             *  property name = `fail`
             *  user provided = `--no-fail`
             *
             *    => fail: false
             */
            if (negatedBool.test(key)) {
                keyToSet = key.slice(3);
                return false;
            }
            var outgoing = current.values;
            /**
             * If type is array, never touch the values, return them
             * directly instead
             */
            if (current.type === CliFlagTypes.Array) {
                return outgoing;
            }
            /**
             * If type === 'count'
             */
            if (current.type === CliFlagTypes.Count) {
                return outgoing.length;
            }
            /**
             * If the users always wants a number
             */
            if (current.type === CliFlagTypes.Number) {
                outgoing = current.values.map(Number);
            }
            /**
             * If the users always wants a number
             */
            if (current.type === CliFlagTypes.Boolean) {
                outgoing = current.values.map(Boolean);
            }
            /**
             * If the users always wants a number
             */
            if (current.type === CliFlagTypes.String) {
                outgoing = current.values.map(String);
            }
            /**
             * If there was only a single value, just return the single value
             */
            if (outgoing.length === 1)
                return outgoing[0];
            /**
             * Return everything in the values array (this accounts for multiples)
             */
            return outgoing;
        })();
        /**
         * And finally we use the key & value
         * determined to set this item on the flags
         */
        _.set(obj, keyToSet, valueToSet);
        return obj;
    }, {});
}
/**
 * Either add a value to an existing values[] or create a new one.
 */
function addValuesToKey(key, values, target) {
    var current = target[key];
    // add 'true' where there's no value
    var valuesToAdd = (function () {
        if (values.length === 0)
            return [true];
        return values;
    })();
    // new
    if (current === undefined) {
        target[key] = { values: valuesToAdd };
        return;
    }
    // existing
    current.values.push.apply(current.values, valuesToAdd);
}
function resolveValues(flags, opts) {
    var keys = Object.keys(opts);
    /**
     * Create a matching object as given options, but with
     * 'values' array
     */
    var output = (function () {
        return keys.reduce(function (obj, key) {
            obj[key] = _.assign({}, opts[key]);
            obj[key].values = [];
            return obj;
        }, {});
    })();
    var dangling = [];
    /**
     * Look at each item and decide how to add this value
     * (it may be an alias etc)
     */
    flags.forEach(function (flag) {
        var key = flag[0];
        // key === p
        var aliasMatch = keys.filter(function (x) {
            return [].concat(opts[x].alias).indexOf(key) > -1;
        });
        var keyToAdd = (function () {
            if (aliasMatch.length)
                return aliasMatch[0];
            return key;
        })();
        if (flag.length === 1) {
            addValuesToKey(keyToAdd, [], output);
            return;
        }
        else if (flag.length > 1) {
            if (!opts[keyToAdd] || (opts[keyToAdd].type !== CliFlagTypes.Array)) {
                addValuesToKey(keyToAdd, flag.slice(1, 2), output);
                dangling.push.apply(dangling, flag.slice(2));
                return;
            }
        }
        // Here the current flag was not specified
        // in the options, so just add it
        addValuesToKey(keyToAdd, flag.slice(1), output);
    });
    /**
     * Finally, strip anything that does not contain a
     * value. This happens when a user provided an option,
     * but no flag was given.
     */
    var outgoing = Object.keys(output).reduce(function (obj, key) {
        if (!output[key].values.length)
            return obj;
        obj[key] = output[key];
        return obj;
    }, {});
    return { flags: outgoing, input: dangling };
}
function isFlag(incoming) {
    return incoming.slice(0, 2) === "--" || incoming[0] === "-";
}
// With thanks to yargs parser
function tokenize(argString) {
    if (Array.isArray(argString))
        return argString;
    var i = 0;
    var c = null;
    var opening = null;
    var args = [];
    for (var ii = 0; ii < argString.length; ii++) {
        c = argString.charAt(ii);
        // split on spaces unless we're in quotes.
        if (c === " " && !opening) {
            i++;
            continue;
        }
        // don't split the string if we're in matching
        // opening or closing single and double quotes.
        if (c === opening) {
            opening = null;
            continue;
        }
        else if ((c === "'" || c === "\"") && !opening) {
            opening = c;
            continue;
        }
        if (!args[i])
            args[i] = "";
        args[i] += c;
    }
    return args;
}
function firstFlagPos(items) {
    var i = -1;
    items.some(function (x, index) {
        if (isFlag(x)) {
            i = index;
            return true;
        }
    });
    return i;
}
function hasSetter(incoming) {
    var equals = incoming.indexOf("=");
    if (equals === -1)
        return false;
    if (incoming.length > equals + 1)
        return true;
    return false;
}
function propName(incoming) {
    return incoming.replace(/^--?/, "");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLnBhcnNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NsaS5wYXJzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBa0N0QyxJQUFZLFlBTVg7QUFORCxXQUFZLFlBQVk7SUFDcEIscUNBQWEsT0FBTyxXQUFBLENBQUE7SUFDcEIsc0NBQWMsUUFBUSxZQUFBLENBQUE7SUFDdEIsdUNBQWUsU0FBUyxhQUFBLENBQUE7SUFDeEIsc0NBQWMsUUFBUSxZQUFBLENBQUE7SUFDdEIscUNBQWEsT0FBTyxXQUFBLENBQUE7QUFDeEIsQ0FBQyxFQU5XLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBTXZCO0FBZ0JEOztHQUVHO0FBQ0gsU0FBd0IsS0FBSyxDQUFDLEtBQXNCLEVBQUUsSUFBa0I7SUFDcEUsSUFBSSxHQUFHLElBQUksSUFBaUIsRUFBRSxDQUFDO0lBRS9CLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN0QixPQUFPLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDbEM7SUFFRCxlQUFlO0lBQ2YsT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzdDLENBQUM7QUFURCx3QkFTQztBQUVELFNBQVMsVUFBVSxDQUFDLFFBQWtCLEVBQUUsSUFBaUI7SUFFckQsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCLElBQU0sSUFBSSxHQUFHLENBQUM7UUFDVixJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFD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