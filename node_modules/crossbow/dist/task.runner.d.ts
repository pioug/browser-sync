import { Tasks } from "./task.resolve";
import { SequenceItem } from "./task.sequence.factories";
import { CommandTrigger } from "./command.run";
import Rx = require("rx");
import Immutable = require("immutable");
export interface Runner {
    series: (ctx?: RunContext) => Rx.Observable<TaskReport>;
    parallel: (ctx?: RunContext) => Rx.Observable<TaskReport>;
    sequence: SequenceItem[];
}
export interface TaskRunner {
    tasks: Tasks;
    sequence: SequenceItem[];
    runner: Runner;
}
export interface TaskStats {
    startTime: number;
    endTime: number;
    duration: number;
    started: boolean;
    completed: boolean;
    errors: Error[];
    skipped?: boolean;
    skippedReadon?: TaskSkipReasons;
}
export interface TaskErrorStats {
    endTime: number;
    completed: boolean;
    errors: Error[];
    cbError?: boolean;
    cbExitCode?: number;
}
export interface Report {
    item: SequenceItem;
    type: TaskReportType;
}
export declare enum TaskReportType {
    start,
    end,
    error
}
export declare enum TaskSkipReasons {
    SkipFlag,
    IfChanged
}
export interface TaskReport extends Report {
    stats: TaskStats;
}
export interface TaskErrorReport extends Report {
    stats: TaskErrorStats;
}
export declare type RunContext = Immutable.Map<string, any>;
/**
 * This creates a wrapper around the actual function that will be run.
 * This done to allow the before/after reporting to work as expected for consumers
 */
export declare function time(scheduler?: any): any;
export declare function createObservableFromSequenceItem(item: SequenceItem, trigger: CommandTrigger, ctx: RunContext): Rx.Observable<{}>;
/**
 * Create a new stats object with startTime
 */
export declare function getStartStats(startTime: number, additional?: {
    [index: string]: any;
}): TaskStats;
