import { Task } from "./task.resolve";
import { CommandTrigger } from "./command.run";
import { Runner } from "./task.runner";
import { SequenceItem } from "./task.sequence.factories";
import { TaskReport } from "./task.runner";
export declare function createFlattenedSequence(tasks: Task[], trigger: CommandTrigger): SequenceItem[];
/**
 * If the current TaskType is an InlineFunction or
 * module to be run,
 */
export interface ITaskOptions {
    _default?: any;
    [index: string]: any;
}
/**
 *           ******************
 * Where the **--~~Magic~~--** happens!!!
 *           ******************
 *
 * Creating a task runner in crossbow is really about
 * wrapping the process of running the tasks in a way
 * that allows comprehensive logging/reporting
 *
 * Series & Parallel have different semantics and are
 * therefor handled separately.
 *
 * Note that everything here is completely lazy and
 * nothing will be executed until a user calls subscribe
 */
export declare function createRunner(items: SequenceItem[], trigger: CommandTrigger): Runner;
/**
 * After a bunch of tasks have run, we need to link up task-ended reports
 * with their original position in the sequence. This will allow us to
 * reconstruct the task render-tree but also show any tasks that errored
 * or did not complete
 * @param sequence
 * @param reports
 * @returns {*}
 */
export declare function decorateSequenceWithReports(sequence: SequenceItem[], reports: TaskReport[]): any;
/**
 * Look at every item in the sequence tree and count how many
 * error have occured
 */
export declare function countSequenceErrors(items: SequenceItem[]): number;
export declare function collectSkippedTasks(items: SequenceItem[], initial: any): SequenceItem[];
export declare function collectRunnableTasks(items: SequenceItem[], initial: SequenceItem[]): SequenceItem[];
