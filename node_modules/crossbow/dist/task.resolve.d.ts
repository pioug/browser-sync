import { TaskError } from "./task.errors";
import { CrossbowInput } from "./index";
import { CommandTrigger } from "./command.run";
import { Task, Tasks } from "./task.resolve";
import { ExternalFile } from "./file.utils";
/**
 * Function.name is es6 & >
 */
export interface CBFunction extends Function {
    name: string;
}
export declare type IncomingTaskItem = string | CBFunction | Task;
export declare type IncomingInlineArray = {
    tasks: Array<IncomingTaskItem>;
    runMode: TaskRunModes;
};
export declare type TaskCollection = Array<IncomingTaskItem>;
export declare enum TaskTypes {
    ExternalTask,
    Adaptor,
    TaskGroup,
    ParentGroup,
    InlineFunction
}
export declare enum TaskOriginTypes {
    CrossbowConfig,
    NpmScripts,
    FileSystem,
    Adaptor,
    InlineFunction,
    InlineArray,
    InlineObject,
    InlineChildObject
}
export declare enum TaskRunModes {
    series,
    parallel
}
/**
 * Factory for creating a new Task Item
 * @param {object} obj
 * @returns {object}
 */
export declare function createTask(obj: any): Task;
/**
 * When a circular reference is detected, exit with the appropriate error
 */
export declare function createCircularReferenceTask(incoming: Task, parents: string[]): Task;
/**
 * Match a task name with a top-level value from 'tasks'
 */
export declare function getTopLevelValue(baseTaskName: string, input: CrossbowInput): any;
/**
 * Anything that begins @ is always an adaptor and will skip
 * file i/o etc.
 * @param taskName
 * @param parents
 * @returns {Task}
 */
export declare function createAdaptorTask(taskName: any, parents: any): Task;
/**
 * Look at a hash and determine if the incoming 'taskName'
 * could match a valid taskName.
 * eg:
 *  $ crossbow run shane
 *
 * -> matches:   'shane' & 'shane@p'
 */
export declare function maybeTaskNames(tasks: {}, taskName: string): string[];
export declare function resolveTasks(taskCollection: TaskCollection, trigger: CommandTrigger): Tasks;
export interface Task {
    adaptor?: string;
    command?: string;
    valid: boolean;
    taskName: string;
    baseTaskName: string;
    subTasks: string[];
    externalTasks: ExternalFile[];
    tasks: Task[];
    rawInput: string;
    parents: string[];
    errors: TaskError[];
    runMode: TaskRunModes;
    startTime?: number;
    endTime?: number;
    duration?: number;
    query: any;
    flags: any;
    options: any;
    cbflags: string[];
    origin: TaskOriginTypes;
    type: TaskTypes;
    inlineFunctions: Array<CBFunction>;
    env: any;
    description: string;
    skipped: boolean;
    ifChanged: string[];
}
export interface TasknameWithOrigin {
    items: string[];
    origin: TaskOriginTypes;
}
export interface Tasks {
    valid: Task[];
    invalid: Task[];
    all: Task[];
}
