"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var command_run_1 = require("./command.run");
var watch_runner_1 = require("./watch.runner");
var watch_resolve_1 = require("./watch.resolve");
var watch_shorthand_1 = require("./watch.shorthand");
var watch_before_1 = require("./watch.before");
var Rx = require("rx");
var Immutable = require("immutable");
var watch_file_watcher_1 = require("./watch.file-watcher");
var command_watch_interactive_1 = require("./command.watch.interactive");
var watch_utils_1 = require("./watch.utils");
var reporter_resolve_1 = require("./reporter.resolve");
var task_runner_1 = require("./task.runner");
var seq = require("./task.sequence");
var debug = require("debug")("cb:command.watch");
var _ = require("../lodash.custom");
var WatchCommandEventTypes;
(function (WatchCommandEventTypes) {
    WatchCommandEventTypes[WatchCommandEventTypes["SetupError"] = "SetupError"] = "SetupError";
    WatchCommandEventTypes[WatchCommandEventTypes["FileEvent"] = "FileEvent"] = "FileEvent";
    WatchCommandEventTypes[WatchCommandEventTypes["WatchTaskReport"] = "WatchTaskReport"] = "WatchTaskReport";
    WatchCommandEventTypes[WatchCommandEventTypes["WatchRunnerComplete"] = "WatchRunnerComplete"] = "WatchRunnerComplete";
    WatchCommandEventTypes[WatchCommandEventTypes["BeforeTasksComplete"] = "BeforeTasksComplete"] = "BeforeTasksComplete";
})(WatchCommandEventTypes = exports.WatchCommandEventTypes || (exports.WatchCommandEventTypes = {}));
function executeWatchCommand(trigger) {
    var cli = trigger.cli, input = trigger.input, config = trigger.config, reporter = trigger.reporter;
    var _a = getWatchCommandSetup(trigger), beforeTasks = _a.beforeTasks, watchTasks = _a.watchTasks, watchRunners = _a.watchRunners;
    /**
     * Never continue if any BEFORE tasks were flagged as invalid
     */
    if (beforeTasks.tasks.invalid.length) {
        reporter({
            type: reporter_resolve_1.ReportTypes.BeforeWatchTaskErrors,
            data: {
                watchTasks: watchTasks, trigger: trigger
            }
        });
        return Rx.Observable.just({
            setup: {
                watchTasks: watchTasks,
                watchRunners: watchRunners,
                beforeTasks: beforeTasks,
                errors: [{ type: reporter_resolve_1.ReportTypes.BeforeWatchTaskErrors, data: { watchTasks: watchTasks, trigger: trigger } }]
            },
            update$: Rx.Observable.empty()
        });
    }
    /**
     * Never continue if any tasks were flagged as
     * // todo, how do we get here
     */
    if (watchTasks.invalid.length) {
        reporter({ type: reporter_resolve_1.ReportTypes.WatchTaskErrors, data: { watchTasks: watchTasks.all, cli: cli, input: input } });
        return Rx.Observable.just({
            setup: {
                watchTasks: watchTasks,
                watchRunners: watchRunners,
                beforeTasks: beforeTasks,
                errors: [{ type: reporter_resolve_1.ReportTypes.WatchTaskErrors, data: { watchTasks: watchTasks, trigger: trigger } }]
            },
            update$: Rx.Observable.empty()
        });
    }
    /**
     * Never continue if any runners are invalid
     */
    if (watchRunners.invalid.length) {
        watchRunners.invalid.forEach(function (runner) {
            reporter({ type: reporter_resolve_1.ReportTypes.WatchTaskTasksErrors, data: { tasks: runner._tasks.all, runner: runner, config: config } });
        });
        return Rx.Observable.just({
            setup: {
                watchTasks: watchTasks,
                watchRunners: watchRunners,
                beforeTasks: beforeTasks,
                errors: [{ type: reporter_resolve_1.ReportTypes.WatchTaskTasksErrors }]
            },
            update$: Rx.Observable.empty()
        });
    }
    /**
     * If there are no before tasks to execute, just begin the watchers
     */
    if (!beforeTasks.tasks.valid.length) {
        reporter({ type: reporter_resolve_1.ReportTypes.Watchers, data: { watchTasks: watchTasks.valid, config: config } });
        return Rx.Observable.just({
            setup: {
                watchTasks: watchTasks,
                watchRunners: watchRunners,
                beforeTasks: beforeTasks,
                errors: []
            },
            update$: watch_file_watcher_1.createObservablesForWatchers(watchRunners.valid, trigger)
        });
    }
    reporter({ type: reporter_resolve_1.ReportTypes.BeforeTaskList, data: { sequence: beforeTasks.sequence, cli: cli, config: trigger.config } });
    var withBefore$ = Rx.Observable.zip(
    /**
     * Timestamp the beginning
     */
    Rx.Observable.just(true).timestamp(config.scheduler).map(function (x) { return x.timestamp; }), 
    /**
     * Run the tasks
     */
    beforeTasks.runner.series().toArray().timestamp(config.scheduler), 
    /**
     * Combine the start time + report from the runner
     */
    function (start, x) {
        var reports = x.value;
        var endtime = x.timestamp;
        return { duration: endtime - start, reports: reports };
    })
        /**
         * At this point, before tasks have executed and we have
         * access to all task reports + run duration
         */
        .flatMap(function (x) {
        var duration = x.duration, reports = x.reports;
        var sequence = seq.decorateSequenceWithReports(beforeTasks.sequence, reports);
        var errors = reports.filter(function (x) { return x.type === task_runner_1.TaskReportType.error; });
        reporter({
            type: reporter_resolve_1.ReportTypes.BeforeTasksSummary,
            data: {
                sequence: sequence,
                cli: cli,
                config: config,
                runtime: duration,
                errors: errors
            }
        });
        var beforeReport = {
            type: WatchCommandEventTypes.BeforeTasksComplete,
            data: {
                reports: reports,
                errors: errors
            }
        };
        /**
         * If an error occurred, and the user did not provide --no-fail flag
         * don't continue with the watchers
         */
        if (errors.length && config.fail) {
            return Rx.Observable.just(beforeReport);
        }
        /**
         * Report running watchers
         */
        reporter({ type: reporter_resolve_1.ReportTypes.Watchers, data: { watchTasks: watchTasks.valid, config: config } });
        /**
         * Send the before report followed by the following watch task reports
         */
        return Rx.Observable.concat(Rx.Observable.just(beforeReport), watch_file_watcher_1.createObservablesForWatchers(watchRunners.valid, trigger));
    });
    return Rx.Observable.just({
        setup: {
            watchTasks: watchTasks,
            watchRunners: watchRunners,
            beforeTasks: beforeTasks,
            errors: []
        },
        update$: withBefore$
    });
}
function handleIncomingWatchCommand(cli, input, config, reporter) {
    var topLevelWatchers = watch_utils_1.stripBlacklisted(Object.keys(input.watch));
    debug("top level watchers available", topLevelWatchers);
    var sharedMap = new Rx.BehaviorSubject(Immutable.Map({}));
    /**
     * If the interactive flag was given (-i), always try
     * that first.
     */
    if (config.interactive) {
        return enterInteractive();
    }
    /**
     * If the user did not provide a watcher name
     */
    if (cli.input.length === 1) {
        if (input.watch.default !== undefined) {
            var moddedCliInput = cli.input.slice();
            cli.input = moddedCliInput.concat("default");
            return executeWatchCommand(watch_shorthand_1.getModifiedWatchContext({
                shared: sharedMap,
                cli: cli,
                input: input,
                config: config,
                reporter: reporter,
                type: command_run_1.TriggerTypes.watcher
            }));
        }
        return enterInteractive();
    }
    /**
     * If no watchers given, or if user has selected interactive mode,
     * show the UI for watcher selection
     */
    function enterInteractive() {
        if (!topLevelWatchers.length) {
            reporter({ type: reporter_resolve_1.ReportTypes.NoWatchersAvailable });
            return Rx.Observable.just({
                setup: {
                    errors: [{ type: reporter_resolve_1.ReportTypes.NoWatchersAvailable }]
                },
                update$: Rx.Observable.empty()
            });
        }
        reporter({ type: reporter_resolve_1.ReportTypes.NoWatchTasksProvided });
        return command_watch_interactive_1.default(cli, input, config)
            .flatMap(function (answers) {
            var cliMerged = _.merge({}, cli, { input: answers.watch });
            return executeWatchCommand({
                shared: sharedMap,
                cli: cliMerged,
                input: input,
                config: config,
                reporter: reporter,
                type: command_run_1.TriggerTypes.watcher
            });
        });
    }
    return executeWatchCommand(watch_shorthand_1.getModifiedWatchContext({
        shared: sharedMap,
        cli: cli,
        input: input,
        config: config,
        reporter: reporter,
        type: command_run_1.TriggerTypes.watcher
    }));
}
exports.default = handleIncomingWatchCommand;
function getWatchCommandSetup(trigger) {
    var cli = trigger.cli, input = trigger.input, config = trigger.config, reporter = trigger.reporter;
    /**
     * task Tracker for external observers
     * @type {Subject<T>}
     */
    trigger.tracker = new Rx.Subject();
    trigger.tracker$ = trigger.tracker.share();
    /**
     * First Resolve the task names given in input.
     */
    var watchTasks = watch_resolve_1.resolveWatchTasks(trigger.cli.input, trigger);
    /**
     * Create runners for watch tasks;
     */
    // todo - resolve parent+child for watchers
    var watchRunners = watch_runner_1.createWatchRunners(watchTasks, trigger);
    /**
     * Get a special runner that will executeWatchCommand before
     * watchers begin
     * @type {BeforeTasks}
     */
    var beforeTasks = watch_before_1.getBeforeTaskRunner(trigger, watchTasks);
    /**
     *
     */
    return { watchRunners: watchRunners, watchTasks: watchTasks, beforeTasks: beforeTasks, errors: [] };
}
exports.getWatchCommandSetup = getWatchCommandSetup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbWFuZC53YXRjaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tYW5kLndhdGNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsNkNBQTJEO0FBRzNELCtDQUFnRTtBQUNoRSxpREFBOEQ7QUFDOUQscURBQTBEO0FBQzFELCtDQUFnRTtBQUNoRSx1QkFBMEI7QUFDMUIscUNBQXdDO0FBQ3hDLDJEQUF3RztBQUN4Ryx5RUFBZ0U7QUFDaEUsNkNBQStDO0FBQy9DLHVEQUErQztBQUUvQyw2Q0FBeUQ7QUFDekQscUNBQXVDO0FBR3ZDLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ25ELElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBNEJ0QyxJQUFZLHNCQU1YO0FBTkQsV0FBWSxzQkFBc0I7SUFDOUIsOERBQTRCLFlBQVksZ0JBQUEsQ0FBQTtJQUN4Qyw2REFBNEIsV0FBVyxlQUFBLENBQUE7SUFDdkMsbUVBQTRCLGlCQUFpQixxQkFBQSxDQUFBO0lBQzdDLHVFQUE0QixxQkFBcUIseUJBQUEsQ0FBQTtJQUNqRCx1RUFBNEIscUJBQXFCLHlCQUFBLENBQUE7QUFDckQsQ0FBQyxFQU5XLHNCQUFzQixHQUF0Qiw4QkFBc0IsS0FBdEIsOEJBQXNCLFFBTWpDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxPQUF1QjtJQUV6QyxJQUFBLGlCQUFHLEVBQUUscUJBQUssRUFBRSx1QkFBTSxFQUFFLDJCQUFRLENBQVk7SUFFekMsSUFBQSxrQ0FBdUUsRUFBdEUsNEJBQVcsRUFBRSwwQkFBVSxFQUFFLDhCQUE2QyxDQUFDO0lBRTlFOztPQUVHO0lBQ0gsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7UUFDbEMsUUFBUSxDQUFDO1lBQ0wsSUFBSSxFQUFFLDhCQUFXLENBQUMscUJBQXFCO1lBQ3ZDLElBQUks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