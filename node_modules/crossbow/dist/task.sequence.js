"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var task_resolve_1 = require("./task.resolve");
var _ = require("../lodash.custom");
var Rx = require("rx");
var Observable = Rx.Observable;
var adaptors = require("./adaptors");
var Immutable = require("immutable");
var task_sequence_factories_1 = require("./task.sequence.factories");
var task_runner_1 = require("./task.runner");
var task_utils_1 = require("./task.utils");
function createFlattenedSequence(tasks, trigger) {
    return flatten(tasks, []);
    function flatten(items, initial, options, viaName) {
        return items.reduce(function (all, task) {
            /**
             * If the current task has child tasks, we build a tree of
             * nested observables for it (a task with children cannot itself
             * be a task that should be run)
             */
            if (task.type === task_resolve_1.TaskTypes.TaskGroup || task.type === task_resolve_1.TaskTypes.ParentGroup) {
                /**
                 * If we're looking at a group of tasks that was run
                 * with sub-tasks, we need to resolve differently to
                 * allow things such as parallel running to work as expected
                 */
                if (task.subTasks.length && task.tasks.length) {
                    /**
                     * Build the list of tasks/groups
                     * @type {Array}
                     */
                    var output = resolveGroupOfTasks(task, trigger.input);
                    /**
                     * Wrap as parallel group if this task has a runMode of 'parallel'
                     */
                    if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
                        return all.concat(task_sequence_factories_1.createSequenceParallelGroup({
                            taskName: task.taskName,
                            items: output,
                            skipped: task.skipped
                        }));
                    }
                    /**
                     * Wrap as a series group if this task has a runMode of 'series'
                     */
                    if (task.runMode === task_resolve_1.TaskRunModes.series) {
                        return all.concat(task_sequence_factories_1.createSequenceSeriesGroup({
                            taskName: task.taskName,
                            items: output,
                            skipped: task.skipped
                        }));
                    }
                }
                /**
                 * If the current task was marked as `parallel`, all immediate children
                 * of (this task) will be run in `parallel`
                 */
                if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
                    return all.concat(resolveGroup(task, task_sequence_factories_1.createSequenceParallelGroup));
                }
                /**
                 * If the current task was marked as `series`, all immediate child tasks
                 * will be queued and run in series - each waiting until the previous
                 * one has completed
                 */
                if (task.runMode === task_resolve_1.TaskRunModes.series) {
                    return all.concat(resolveGroup(task, task_sequence_factories_1.createSequenceSeriesGroup));
                }
            }
            /**
             * At this point, we must be dealing with a task that should be run,
             * so we first check if it's an adaptor @ task first
             */
            if (task.type === task_resolve_1.TaskTypes.Adaptor) {
                return all.concat(getSequenceItemWithOptions(task, trigger, adaptors[task.adaptor].create(task, trigger), {}));
            }
            /**
             * Finally, if the does not have children tasks & is not an
             * adaptor task it must have at least 1 associated module
             * (or an inline function) so we can begin working with it
             * by first resolving the top-level options object for it.
             */
            var localOptions = _.assign({}, loadTopLevelOptions(task, trigger), options);
            /**
             * Decide where the callable function is coming from
             * (inline function, external task etc)
             * @type {CBFunction}
             */
            var callable = (function () {
                if (task.type === task_resolve_1.TaskTypes.InlineFunction) {
                    return task.inlineFunctions[0];
                }
                return require(task.externalTasks[0].resolved);
            })();
            /**
             * Take the callable and create items with it + options
             */
            return all.concat(resolveFromFunction(task, callable, trigger, localOptions, viaName));
        }, initial);
    }
    /**
     * Resolve a group of tasks
     * @param task
     * @param groupCreatorFn
     * @param continueFn
     * @returns {any}
     */
    function resolveGroup(task, groupCreatorFn) {
        /**
         * If the group contains no subtasks
         */
        if (!task.subTasks.length) {
            /**
             * If a group has _default options,
             * but here no 'subTasks' were given, use the
             * default options always
             */
            var parentOptions = (function () {
                if (task.options._default !== undefined) {
                    return _.merge({}, task.options._default, task.query, task.flags);
                }
                return task.options;
            })();
            /**
             * Here the group had no direct 'sub tasks', so just return the item
             */
            return [groupCreatorFn({
                    taskName: task.taskName,
                    items: flatten(task.tasks, [], parentOptions),
                    skipped: task.skipped
                })];
        }
        /**
         * Use either subtasks directly, or if '*' was given, use
         * each key in the object to create a task
         */
        var lookupKeys = getLookupKeys(task.subTasks, task.options);
        /**
         * Now for each sub-task create a separate task item
         */
        return lookupKeys.map(function (subTaskName) {
            /**
             * When things like options, flags or query strings
             * were present on this task-group - pass them into the upcoming task instead
             * Order of presedence
             *   flags -> query -> options -> shared
             */
            var taskOptions = _.merge({}, task.options._default, _.get(task.options, subTaskName, {}), task.query, task.flags);
            return groupCreatorFn({
                taskName: task.taskName,
                items: flatten(task.tasks, [], taskOptions, task.taskName + ":" + subTaskName),
                skipped: task.skipped,
                subTaskName: subTaskName
            });
        });
    }
    function resolveGroupOfTasks(task, input) {
        if (task.type === task_resolve_1.TaskTypes.ParentGroup) {
            var opts = _.merge({}, task.options._default, task.query, task.flags);
            return flatten(task.tasks, [], opts, task.taskName);
        }
        var lookupKeys = getLookupKeys(task.subTasks, task.options);
        return lookupKeys.reduce(function (acc, subTaskName) {
            var opts = _.merge({}, task.options._default, _.get(task.options, subTaskName, {}), _.get(input.options, [task.baseTaskName, subTaskName], {}), task.query, task.flags);
            return acc.concat(flatten(task.tasks, [], opts, task.taskName + ":" + subTaskName));
        }, []);
    }
}
exports.createFlattenedSequence = createFlattenedSequence;
function resolveFromFunction(task, callable, trigger, localOptions, viaName) {
    /**
     * If the current item has no sub-tasks, we can return early
     * with a simple task creation using the global options
     *
     * eg:
     *      $ crossbow run sass
     *
     * options:
     *      sass:
     *        input:  "core.scss"
     *        output: "core.css"
     *
     * -> `sass` task will be run with the options
     *    {input: "core.scss", output: "core.css"}
     */
    if (!task.subTasks.length) {
        return getSequenceItemWithOptions(task, trigger, callable, localOptions, viaName);
    }
    /**
     * Get lookup keys for this task
     */
    var lookupKeys = getLookupKeys(task.subTasks, localOptions);
    /**
     * Now generate 1 task per lookup key.
     */
    var group = lookupKeys.reduce(function (acc, optionKey) {
        /**
         * `optionKey` here will be a string that represented the subTask
         * name, so we use that to try and find a child key
         * in the options that matched it.
         * */
        var currentOptionObject = _.merge({}, localOptions._default, _.get(localOptions, optionKey));
        var sequenceItems = getSequenceItemWithOptions(task, trigger, callable, currentOptionObject, optionKey)
            .map(function (seqItem) {
            seqItem.subTaskName = optionKey;
            return seqItem;
        });
        return acc.concat(sequenceItems);
    }, []);
    /**
     * Don't create a 'group' if we're only talking about 1 item
     */
    if (group.length === 1) {
        return group;
    }
    if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
        return [task_sequence_factories_1.createSequenceParallelGroup({
                taskName: task.taskName,
                items: group,
                skipped: task.skipped
            })];
    }
    /**
     * If the current task was marked as `series`, all immediate child tasks
     * will be queued and run in series - each waiting until the previous
     * one has completed
     */
    if (task.runMode === task_resolve_1.TaskRunModes.series) {
        return [task_sequence_factories_1.createSequenceSeriesGroup({
                taskName: task.taskName,
                items: group,
                skipped: task.skipped
            })];
    }
}
function getSequenceItemWithOptions(task, trigger, imported, options, viaName) {
    /**
     * Merge incoming options with query + flags
     * eg:
     *     $  sass?input=css/core.css --production
     *     -> sass
     *          input: css/core.css
     *          production: true
     */
    var mergedOptionsWithQuery = _.merge({}, options, task.options, task.query, task.flags);
    /**
     * If the module did not export a function, but has a 'tasks'
     * property that is an array, use each function from it
     * eg:
     *  module.exports.tasks = [sass, cssmin, version-rev]
     */
    if (imported.tasks && Array.isArray(imported.tasks)) {
        return imported.tasks.map(function (importedFn, i) {
            return task_sequence_factories_1.createSequenceTaskItem({
                fnName: getFunctionName(imported, i + 1),
                factory: importedFn,
                task: task,
                options: mergedOptionsWithQuery,
                viaName: viaName
            });
        });
    }
    /**
     * If the module exported a function, use that as the factory
     * and return a single task for it.
     * eg:
     *  module.exports = function runSass() {}
     */
    if (typeof imported === "function") {
        return [task_sequence_factories_1.createSequenceTaskItem({
                fnName: getFunctionName(imported, 0),
                factory: imported,
                task: task,
                options: mergedOptionsWithQuery,
                viaName: viaName
            })];
    }
}
/**
 * For reporting purposes, try to 'name' a function
 */
function getFunctionName(fn, count) {
    if (count === void 0) { count = 0; }
    if (fn.name === undefined) {
        return "Anonymous Function " + count;
    }
    return fn.name;
}
/**
 *           ******************
 * Where the **--~~Magic~~--** happens!!!
 *           ******************
 *
 * Creating a task runner in crossbow is really about
 * wrapping the process of running the tasks in a way
 * that allows comprehensive logging/reporting
 *
 * Series & Parallel have different semantics and are
 * therefor handled separately.
 *
 * Note that everything here is completely lazy and
 * nothing will be executed until a user calls subscribe
 */
function createRunner(items, trigger) {
    return {
        sequence: items,
        series: function (ctx) {
            if (!ctx)
                ctx = Immutable.Map({});
            var flattened = createObservableTree(items, [], false, ctx);
            var run = Observable
                .from(flattened)
                .concatAll()
                .catch(function (x) { return Rx.Observable.empty(); });
            return run;
        },
        parallel: function (ctx) {
            if (!ctx)
                ctx = Immutable.Map({});
            var flattened = createObservableTree(items, [], true, ctx);
            var run = Observable.from(flattened).mergeAll();
            return run;
        }
    };
    /**
     * Any task in 'Parallel' run mode that throws an
     * error should not adversely affect sibling tasks
     */
    function shouldCatch(trigger) {
        return trigger.config.runMode === task_resolve_1.TaskRunModes.parallel;
    }
    /**
     * Create a nested tree of Observables that can contain tasks
     * alongside parallel/series groups. To understand how this works
     * you can think of the following to be an accurate representation of
     * what this function produces:
     *
     * const out = [
     Observable.concat(
     task1(),
     task2()
     ),
     Observable.concat(
     task3(),
     task4(),
     Observable.concat(
     task5(),
     task6(),
     task7()
     )
     )
     ];
     *
     */
    function createObservableTree(items, initial, addCatch, ctx) {
        if (addCatch === void 0) { addCatch = false; }
        return items.reduce(function (all, item) {
            var output;
            /**
             * If the current task was marked as `parallel`, all immediate children
             * of (this task) will be run in `parallel`
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.ParallelGroup) {
                output = Observable.merge(createObservableTree(item.items, [], shouldCatch(trigger), ctx));
            }
            /**
             * If the current task was marked as `series`, all immediate child tasks
             * will be queued and run in series - each waiting until the previous
             * one has completed
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.SeriesGroup) {
                output = Observable.concat(createObservableTree(item.items, [], false, ctx));
            }
            /**
             * Finally is item is a task, create an observable for it.
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.Task && item.factory) {
                output = task_runner_1.createObservableFromSequenceItem(item, trigger, ctx);
            }
            /**
             * Should we add a catch clause to this item to enable
             * siblings to continue when a task errors
             */
            if (addCatch || !trigger.config.fail) {
                return all.concat(output.catch(function (x) { return Rx.Observable.empty(); }));
            }
            return all.concat(output);
        }, initial);
    }
}
exports.createRunner = createRunner;
/**
 * From user input, try to locate a options object
 */
function loadTopLevelOptions(task, trigger) {
    // todo - more robust way of matching options -> tasks
    var fullMatch = _.get(trigger.input.options, [task.taskName]);
    if (fullMatch !== undefined) {
        /**
         * If this item was given as top-level + options
         * just return the options here
         */
        if (fullMatch.options && fullMatch.tasks) {
            return fullMatch.options;
        }
        /**
         * If this task has a _default key, don't pass
         * all the options in, just pass the stuff under default
         */
        if (task.subTasks.length === 0 && fullMatch._default !== undefined) {
            return fullMatch._default;
        }
        return fullMatch;
    }
    if (task_utils_1.isInternal(task.rawInput)) {
        var lookup = task.taskName.replace(/(.+?)_internal_fn_\d{0,10}/, "");
        var fromInternal = _.get(trigger.input.options, [lookup]);
        if (fromInternal !== undefined) {
            return fromInternal;
        }
    }
    return {};
}
/**
 * After a bunch of tasks have run, we need to link up task-ended reports
 * with their original position in the sequence. This will allow us to
 * reconstruct the task render-tree but also show any tasks that errored
 * or did not complete
 * @param sequence
 * @param reports
 * @returns {*}
 */
function decorateSequenceWithReports(sequence, reports) {
    return addMany(sequence, []);
    function addMany(sequence, initial) {
        return sequence.reduce(function (all, item) {
            var c = _.assign({}, item);
            if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
                c.stats = getMergedStats(item, reports);
                return all.concat(c);
            }
            else {
                c.items = addMany(item.items, []);
                return all.concat(c);
            }
        }, initial);
    }
}
exports.decorateSequenceWithReports = decorateSequenceWithReports;
/**
 * Look at every item in the sequence tree and count how many
 * error have occured
 */
function countSequenceErrors(items) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            var errors = _.get(item, "stats.errors", []);
            if (errors.length) {
                return acc + errors.length;
            }
            return acc;
        }
        return acc + countSequenceErrors(item.items);
    }, 0);
}
exports.countSequenceErrors = countSequenceErrors;
function collectSkippedTasks(items, initial) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            if (item.stats.skipped) {
                return acc.concat(item);
            }
            return acc;
        }
        return acc.concat(collectSkippedTasks(item.items, []));
    }, initial);
}
exports.collectSkippedTasks = collectSkippedTasks;
function collectRunnableTasks(items, initial) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            return acc.concat(item);
        }
        return acc.concat(collectRunnableTasks(item.items, []));
    }, initial);
}
exports.collectRunnableTasks = collectRunnableTasks;
/**
 * Look at the reports array to find stats linked to a
 * given task
 */
function getMergedStats(item, reports) {
    var match = reports.filter(function (report) {
        return report.item.seqUID === item.seqUID;
    });
    var start = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.start; })[0];
    var error = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.error; })[0];
    var end = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.end; })[0];
    if (start && end) {
        return _.assign({}, start.stats, end.stats);
    }
    if (start && error) {
        var duration = error.stats.endTime - start.stats.startTime;
        return _.assign({}, start.stats, error.stats, { duration: duration });
    }
    if (start) {
        return _.assign({}, start.stats);
    }
    return { item: item, errors: [] };
}
/**
 * When we know a task has `subTasks` we need to check if
 * if the first entry in the subTasks array is a `*` - then
 * the user wants to run all tasks under this options
 * object. So we need to get the keys and use each one as a lookup
 * on the local options. (minus any excluded tasks)
 *
 * eg:
 *     $ crossbow run sass:*
 *
 * options:
 *   sass:
 *     site:  {input: "core.scss"}
 *     debug: {input: "debug.scss"}
 *
 * lookupKeys = ['site', 'debug']
 */
var blacklistedSubTaskNames = ["_default"];
function getLookupKeys(subTasks, topLevelObject) {
    if (subTasks[0] === "*") {
        return Object.keys(topLevelObject)
            .filter(function (x) { return blacklistedSubTaskNames.indexOf(x) === -1; });
    }
    return subTasks;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay5zZXF1ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90YXNrLnNlcXVlbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0NBQXVEO0FBQ3ZELElBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QixJQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDO0FBRWpDLHFDQUF1QztBQUN2QyxxQ0FBd0M7QUFJeEMscUVBT21DO0FBRW5DLDZDQUErRTtBQUUvRSwyQ0FBd0M7QUFFeEMsU0FBZ0IsdUJBQXVCLENBQUMsS0FBYSxFQUFFLE9BQXVCO0lBRTFFLE9BQU8sT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztJQUUxQixTQUFTLE9BQU8sQ0FBQyxLQUFhLEVBQUUsT0FBdUIsRUFBRSxPQUFRLEVBQUUsT0FBUTtRQUV2RSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBQyxHQUFHLEVBQUUsSUFBVTtZQUVoQzs7OztlQUlHO1lBQ0gsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLHdCQUFTLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssd0JBQVMsQ0FBQyxXQUFXLEVBQUU7Z0JBRTFFOzs7O21CQUlHO2dCQUNILElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7b0JBRTNDOzs7dUJBR0c7b0JBQ0gsSUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFeEQ7O3VCQUVHO29CQUNILElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSywyQkFBWSxDQUFDLFFBQVEsRUFBRTt3QkFDeEMsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLHFE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