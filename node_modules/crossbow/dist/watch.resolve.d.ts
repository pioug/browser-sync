import { WatchOptions } from "chokidar";
import { WatchTaskError } from "./watch.errors";
import { CrossbowInput } from "./index";
import { Tasks } from "./task.resolve";
import { SequenceItem } from "./task.sequence.factories";
import { Runner } from "./task.runner";
import { CommandTrigger } from "./command.run";
import { TaskCollection } from "./task.resolve";
export declare const defaultWatchOptions: CBWatchOptions;
export interface CBWatchOptions extends WatchOptions {
    throttle: number;
    debounce: number;
    delay: number;
    block: boolean;
    group: number;
}
export interface WatchTask {
    before: string[];
    options: CBWatchOptions;
    watchers: Watcher[];
    name: string;
    errors: WatchTaskError[];
    patterns?: string[];
    tasks?: string[];
}
export interface Watcher {
    patterns: string[];
    tasks: TaskCollection;
    options: CBWatchOptions;
    watcherUID: string;
    _tasks?: Tasks;
    _sequence?: SequenceItem[];
    _runner?: Runner;
    parent?: string;
}
export interface WatchTasks {
    valid: WatchTask[];
    invalid: WatchTask[];
    all: WatchTask[];
}
export declare function resolveWatchTasks(taskNames: string[], trigger: CommandTrigger): WatchTasks;
/**
 * The goal of this function is to produce a flat array containing tasks as strings
 * this allows us to feed that into the task resolution stuff
 */
export declare function resolveBeforeTasks(beforeFlagsFromCliOrConfig: string[], input: CrossbowInput, watchTasks: WatchTask[]): string[];
