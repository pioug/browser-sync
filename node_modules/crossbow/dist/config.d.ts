import { TaskRunModes } from "./task.resolve";
import { LogLevel } from "./reporters/defaultReporter";
import { OutgoingReport, BinDirectoryLookup } from "./reporter.resolve";
import { InitConfigFileTypes } from "./command.init";
import { WatchEvent } from "./watch.file-watcher";
import { ExternalFile, ExternalFileContent } from "./file.utils";
import Rx = require("rx");
import { InputErrorTypes } from "./task.utils";
export declare enum SignalTypes {
    Exit,
    FileWrite
}
export interface CBSignal<T> {
    type: SignalTypes;
    data?: T;
}
export declare type OutgoingSignals = Rx.Subject<CBSignal<ExitSignal | FileWriteSignal>>;
export interface ExitSignal {
    code: number;
}
export interface FileWriteSignal {
    file: ExternalFile;
    content: string;
}
export interface EnvFile {
    path?: string;
    file?: ExternalFileContent;
    prefix?: string[];
    errors: StandardError[];
    input: EnvFile | string;
}
export interface StandardError {
    type: InputErrorTypes;
}
export interface CrossbowConfiguration {
    cwd: string;
    runMode: TaskRunModes;
    verbose: LogLevel;
    parallel: boolean;
    fail: boolean;
    force: boolean;
    reporter: string;
    handoff: boolean;
    input: string[];
    bin: string[];
    binExecutables: string[];
    binDirectories: BinDirectoryLookup[];
    interactive: boolean;
    outputOnly: boolean;
    suppressOutput: boolean;
    progress: boolean;
    loadDefaultInputs: boolean;
    cbfile?: string;
    dump: boolean;
    envPrefix: string;
    envFile: string[] | EnvFile | EnvFile[];
    envFilePrefix: string[];
    envFiles: EnvFile[];
    env: any;
    before: string[];
    type?: InitConfigFileTypes;
    debug: boolean;
    reporters: Array<string | Function>;
    skip: string[];
    tasksDir: string[];
    nodeModulesPaths: string[];
    block?: boolean;
    debounce?: boolean;
    throttle?: boolean;
    fromJson?: string;
    file?: string;
    output?: string;
    dryRun?: boolean;
    dryRunDuration?: number;
    outputObserver?: Rx.Observable<OutgoingReport>;
    fileChangeObserver?: Rx.Observable<WatchEvent>;
    signalObserver?: OutgoingSignals;
    scheduler?: Rx.IScheduler;
}
/**
 * Merge default with incoming opts.
 * Also deal with single char flag
 * @returns {*}
 */
export declare function merge(opts: CrossbowConfiguration | any): CrossbowConfiguration;
